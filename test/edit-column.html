<!doctype html>

<html>

<head>
  <meta charset="UTF-8">
  <title>edit-column test</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
  <script src="../../web-component-tester/browser.js"></script>
  <script src="../../iron-test-helpers/mock-interactions.js"></script>
  <link rel="import" href="../../test-fixture/test-fixture.html">

  <link rel="import" href="helpers.html">
  <link rel="import" href="../vaadin-grid-pro.html">
  <link rel="import" href="../vaadin-grid-pro-edit-column.html">
</head>

<body>
  <test-fixture id="default">
    <template>
      <vaadin-grid-pro>
        <vaadin-grid-pro-edit-column path="name">
          <template class="header">Name</template>
          <template>[[index]] [[item.name]]</template>
          <template class="footer"></template>
        </vaadin-grid-pro-edit-column>
        <vaadin-grid-pro-edit-column path="age"></vaadin-grid-pro-edit-column>
        <vaadin-grid-column path="name"></vaadin-grid-column>
      </vaadin-grid-pro>
    </template>
  </test-fixture>

  <test-fixture id="renderer">
    <template>
      <vaadin-grid-pro>
        <vaadin-grid-pro-edit-column path="name"></vaadin-grid-pro-edit-column>
        <vaadin-grid-pro-edit-column path="age"></vaadin-grid-pro-edit-column>
        <vaadin-grid-column>
          <template>[[item.name]]</template>
        </vaadin-grid-column>
      </vaadin-grid>
    </template>
  </test-fixture>

  <test-fixture id="template">
    <template>
      <vaadin-grid-pro>
        <vaadin-grid-pro-edit-column path="name">
          <template>[[item.name]]</template>
          <template class="editor">
            <input value="{{item.name::input}}">
          </template>
        </vaadin-grid-pro-edit-column>
        <vaadin-grid-pro-edit-column path="age">
          <template class="editor">
            <input type="number" value="{{item.age::input}}">
          </template>
        </vaadin-grid-pro-edit-column>
      </vaadin-grid>
    </template>
  </test-fixture>

  <test-fixture id="editor-type">
    <template>
      <vaadin-grid-pro>
        <vaadin-grid-pro-edit-column path="married"></vaadin-grid-pro-edit-column>
        <vaadin-grid-pro-edit-column path="title"></vaadin-grid-pro-edit-column>
        <vaadin-grid-pro-edit-column path="name"></vaadin-grid-pro-edit-column>
        <vaadin-grid-pro-edit-column path="age"></vaadin-grid-pro-edit-column>
        <vaadin-grid-column>
          <template>[[item.married]]</template>
        </vaadin-grid-column>
      </vaadin-grid>
    </template>
  </test-fixture>

  <dom-module id="user-editor">
    <template>
      <input value="{{user.name::input}}">
    </template>
    <script>
      customElements.whenDefined('vaadin-grid-pro-edit-column').then(() => {
        customElements.define('user-editor', class extends Polymer.Element {
          static get is() {
            return 'user-editor';
          }
          static get properties() {
            return {
              user: {
                type: Object,
                value: () => {
                  return {name: null};
                }
              }
            };
          }
        });
      });
    </script>
  </dom-module>

  <script>
    function getItems() {
      return [
        {name: 'foo', age: 20, married: true, title: 'mrs'},
        {name: 'bar', age: 30, married: false, title: 'ms'},
        {name: 'baz', age: 40, married: false, title: 'mr'}
      ];
    }

    function dblclick(target) {
      target.dispatchEvent(new CustomEvent('dblclick', {bubbles: true, composed: true}));
    }

    function up(target) {
      MockInteractions.keyDownOn(target, 38, [], 'ArrowUp');
    }

    function down(target) {
      MockInteractions.keyDownOn(target, 40, [], 'ArrowDown');
    }

    function tab(target) {
      MockInteractions.keyDownOn(target, 9, [], 'Tab');
    }

    function shiftTab(target) {
      MockInteractions.keyDownOn(target, 9, 'shift', 'Tab');
    }

    function space(target) {
      MockInteractions.keyDownOn(target, 32, [], ' ');
    }

    function enter(target) {
      MockInteractions.keyDownOn(target, 13, [], 'Enter');
    }

    function shiftEnter(target) {
      MockInteractions.keyDownOn(target, 13, 'shift', 'Enter');
    }

    function esc(target) {
      MockInteractions.keyDownOn(target, 27, [], 'Escape');
    }

    function keyDownChar(target, letter, modifier) {
      MockInteractions.keyDownOn(target, letter.charCodeAt(0), modifier, letter);
    }

    describe('edit column', () => {

      function getCellEditor(cell) {
        return cell._column._getEditorComponent(cell);
      }

      describe('keyboard navigation', () => {
        let grid, input;

        beforeEach(() => {
          grid = fixture('default');
          grid.items = getItems();
          flushGrid(grid);
        });

        describe('when `preserveEditMode` is false', () => {
          it('should focus cell next available for editing within a same row in non-edit mode on Tab', () => {
            const firstCell = getContainerCell(grid.$.items, 1, 0);
            dblclick(firstCell._content);
            input = getCellEditor(firstCell);

            const secondCell = getContainerCell(grid.$.items, 1, 1);
            const spy = sinon.spy(secondCell, 'focus');
            tab(input);
            expect(spy).to.be.calledOnce;
          });

          it('should focus previous cell available for editing within a same row in non-edit mode on Shift Tab', () => {
            const firstCell = getContainerCell(grid.$.items, 1, 1);
            dblclick(firstCell._content);
            input = getCellEditor(firstCell);

            const secondCell = getContainerCell(grid.$.items, 1, 0);
            const spy = sinon.spy(secondCell, 'focus');
            shiftTab(input);
            expect(spy).to.be.calledOnce;
          });

          it('should focus cell next available for editing on the next row in non-edit mode on Tab', () => {
            const firstCell = getContainerCell(grid.$.items, 1, 1);
            dblclick(firstCell._content);
            input = getCellEditor(firstCell);

            const secondCell = getContainerCell(grid.$.items, 2, 0);
            const spy = sinon.spy(secondCell, 'focus');
            tab(input);
            expect(spy).to.be.calledOnce;
          });

          it('should focus previous cell available for editing on the previous in non-edit mode on Shift Tab', () => {
            const firstCell = getContainerCell(grid.$.items, 2, 0);
            dblclick(firstCell._content);
            input = getCellEditor(firstCell);

            const secondCell = getContainerCell(grid.$.items, 1, 1);
            const spy = sinon.spy(secondCell, 'focus');
            shiftTab(input);
            expect(spy).to.be.calledOnce;
          });

          it('should focus editable cell on the next row in non-edit mode on Enter, if `allowEnterRowChange` is true', () => {
            grid.allowEnterRowChange = true;
            const firstCell = getContainerCell(grid.$.items, 1, 0);
            enter(firstCell._content);
            input = getCellEditor(firstCell);

            const secondCell = getContainerCell(grid.$.items, 2, 0);
            const spy = sinon.spy(secondCell, 'focus');
            enter(input);
            expect(spy).to.be.calledOnce;
          });

          it('should exit the edit mode for the cell on Enter, if `allowEnterRowChange` is false', () => {
            const firstCell = getContainerCell(grid.$.items, 1, 0);
            dblclick(firstCell._content);
            input = getCellEditor(firstCell);

            enter(input);
            expect(getCellEditor(firstCell)).to.be.not.ok;
          });

          it('should focus editable cell on the previous row in non-edit mode on Shift Enter, if `allowEnterRowChange` is true', () => {
            grid.allowEnterRowChange = true;
            const firstCell = getContainerCell(grid.$.items, 1, 0);
            enter(firstCell._content);
            input = getCellEditor(firstCell);

            const secondCell = getContainerCell(grid.$.items, 0, 0);
            const spy = sinon.spy(secondCell, 'focus');
            shiftEnter(input);
            expect(spy).to.be.calledOnce;
          });

          it('should exit the edit mode for the cell on Shift Enter, if `allowEnterRowChange` is false', () => {
            const firstCell = getContainerCell(grid.$.items, 1, 0);
            dblclick(firstCell._content);
            input = getCellEditor(firstCell);

            shiftEnter(input);
            expect(getCellEditor(firstCell)).to.be.not.ok;
          });
        });

        describe('when `preserveEditMode` is true', () => {
          beforeEach(() => {
            grid.preserveEditMode = true;
          });

          it('should focus cell next available for editing within a same row in edit mode on Tab', () => {
            const firstCell = getContainerCell(grid.$.items, 1, 0);
            dblclick(firstCell._content);
            input = getCellEditor(firstCell);

            const secondCell = getContainerCell(grid.$.items, 1, 1);
            tab(input);
            input = getCellEditor(secondCell);
            expect(input).to.be.ok;
          });

          it('should focus previous cell available for editing within a same row in edit mode on Shift Tab', () => {
            const firstCell = getContainerCell(grid.$.items, 1, 1);
            dblclick(firstCell._content);
            input = getCellEditor(firstCell);

            const secondCell = getContainerCell(grid.$.items, 1, 0);
            shiftTab(input);
            input = getCellEditor(secondCell);
            expect(input).to.be.ok;
          });

          it('should focus cell next available for editing on the next row in edit mode on Tab', () => {
            const firstCell = getContainerCell(grid.$.items, 1, 1);
            dblclick(firstCell._content);
            input = getCellEditor(firstCell);

            const secondCell = getContainerCell(grid.$.items, 2, 0);
            tab(input);
            input = getCellEditor(secondCell);
            expect(input).to.be.ok;
          });

          it('should focus previous cell available for editing on the previous in edit mode on Shift Tab', () => {
            const firstCell = getContainerCell(grid.$.items, 2, 0);
            dblclick(firstCell._content);
            input = getCellEditor(firstCell);

            const secondCell = getContainerCell(grid.$.items, 1, 1);
            shiftTab(input);
            input = getCellEditor(secondCell);
            expect(input).to.be.ok;
          });

          it('should focus editable cell on the next row in edit mode on Enter, if `allowEnterRowChange` is true', () => {
            grid.allowEnterRowChange = true;
            const firstCell = getContainerCell(grid.$.items, 1, 0);
            enter(firstCell._content);
            input = getCellEditor(firstCell);

            const secondCell = getContainerCell(grid.$.items, 2, 0);
            enter(input);
            input = getCellEditor(secondCell);
            expect(input).to.be.ok;
          });

          it('should exit the edit mode for the cell on Enter, if `allowEnterRowChange` is false', () => {
            const firstCell = getContainerCell(grid.$.items, 1, 0);
            dblclick(firstCell._content);
            input = getCellEditor(firstCell);

            enter(input);
            expect(getCellEditor(firstCell)).to.be.not.ok;
          });

          it('should focus editable cell on the previous row in non-edit mode on Shift Enter, if `allowEnterRowChange` is true', () => {
            grid.allowEnterRowChange = true;
            const firstCell = getContainerCell(grid.$.items, 1, 0);
            enter(firstCell._content);
            input = getCellEditor(firstCell);

            const secondCell = getContainerCell(grid.$.items, 0, 0);
            shiftEnter(input);
            input = getCellEditor(secondCell);
            expect(input).to.be.ok;
          });

          it('should exit the edit mode for the cell on Shift Enter, if `allowEnterRowChange` is false', () => {
            const firstCell = getContainerCell(grid.$.items, 1, 0);
            dblclick(firstCell._content);
            input = getCellEditor(firstCell);

            shiftEnter(input);
            expect(getCellEditor(firstCell)).to.be.not.ok;
          });
        });

        it('should exit the edit mode for the cell when pressing ESC', () => {
          const firstCell = getContainerCell(grid.$.items, 1, 0);
          dblclick(firstCell._content);
          input = getCellEditor(firstCell);

          esc(input);
          expect(getCellEditor(firstCell)).to.be.not.ok;
        });

        it('should focus correct editable cell after column reordering', () => {
          grid.columnReorderingAllowed = true;
          const headerContent = [
            getContainerCell(grid.$.header, 0, 0)._content,
            getContainerCell(grid.$.header, 0, 1)._content
          ];
          dragAndDropOver(headerContent[0], headerContent[1]);

          const firstCell = getContainerCell(grid.$.items, 1, 1);
          dblclick(firstCell._content);
          input = getCellEditor(firstCell);

          const secondCell = getContainerCell(grid.$.items, 1, 0);
          const spy = sinon.spy(secondCell, 'focus');
          tab(input);
          expect(spy).to.be.calledOnce;
        });

        it('should focus correct editable cell when column is hidden', () => {
          const column = grid.querySelector('vaadin-grid-pro-edit-column');
          column.hidden = true;

          const firstCell = getContainerCell(grid.$.items, 1, 1);
          dblclick(firstCell._content);
          input = getCellEditor(firstCell);

          const secondCell = getContainerCell(grid.$.items, 2, 1);
          const spy = sinon.spy(secondCell, 'focus');
          tab(input);
          expect(spy).to.be.calledOnce;
        });
      });

      describe('horizontal scrolling to cell', () => {
        let grid, input;

        beforeEach(() => {
          grid = fixture('default');
          grid.items = getItems();
          grid.style.width = '100px'; // column default min width is 100px
          flushGrid(grid);
        });

        it('should scroll to the right on tab when editable cell is outside the viewport', () => {
          const firstCell = getContainerCell(grid.$.items, 1, 0);
          dblclick(firstCell._content);
          input = getCellEditor(firstCell);
          tab(input);

          expect(grid.$.table.scrollLeft).to.be.at.least(100);
        });

        it('should scroll to the left on tab when editable cell is outside the viewport', () => {
          const firstCell = getContainerCell(grid.$.items, 1, 1);
          dblclick(firstCell._content);
          input = getCellEditor(firstCell);
          shiftTab(input);

          expect(grid.$.table.scrollLeft).to.closeTo(1, 1);
        });
      });

      describe('renderer', () => {
        let grid, column, firstCell, input;

        beforeEach(() => {
          grid = fixture('renderer');
          column = grid.firstElementChild;
          grid.items = getItems();

          column.renderer = function(root, owner, model) {
            root.innerHTML = '';
            const wrapper = document.createElement('div');
            const text = document.createTextNode(model.index + ' ' + model.item.name);
            wrapper.appendChild(text);
            root.appendChild(wrapper);
          };

          flushGrid(grid);

          firstCell = getContainerCell(grid.$.items, 0, 0);
        });

        it('should replace renderer and render text-field on editable cell dblclick', () => {
          dblclick(firstCell._content);
          expect(firstCell._renderer).to.not.equal(column.renderer);
          expect(getCellEditor(firstCell)).to.be.ok;
        });

        it('should not call start edit on second dblclick if the cell is in edit mode', () => {
          const spy = sinon.spy(grid, '_startEdit');
          dblclick(firstCell._content);
          input = getCellEditor(firstCell);
          dblclick(input);
          expect(spy).to.be.calledOnce;
        });

        it('should replace renderer and render text-field on editable cell Enter', () => {
          enter(firstCell);
          expect(firstCell._renderer).to.not.equal(column.renderer);
          expect(getCellEditor(firstCell)).to.be.ok;
        });

        it('should replace renderer and render text-field on editable cell Space', () => {
          space(firstCell);
          expect(firstCell._renderer).to.not.equal(column.renderer);
          expect(getCellEditor(firstCell)).to.be.ok;
        });

        it('should restore renderer and render updated content on edited cell Enter', () => {
          enter(firstCell);
          input = getCellEditor(firstCell);
          input.value = 'new';
          enter(input);
          expect(firstCell._renderer).to.equal(column.renderer);
          expect(firstCell._content.textContent).to.equal('0 new');
        });

        it('should restore renderer and reset old content on edited cell Esc', () => {
          const old = firstCell._content.textContent;
          enter(firstCell);
          input = getCellEditor(firstCell);
          input.value = 'new';
          esc(input);
          expect(firstCell._renderer).to.equal(column.renderer);
          expect(firstCell._content.textContent).to.equal(old);
        });

        it('should updated content in the cell of another column using template on Enter', () => {
          enter(firstCell);
          input = getCellEditor(firstCell);
          input.value = 'new';
          enter(input);
          const secondCell = getContainerCell(grid.$.items, 0, 2);
          expect(secondCell._content.textContent).to.equal('new');
        });
      });

      describe('template', () => {
        let grid, column, cell, input;

        beforeEach(() => {
          grid = fixture('default');
          column = grid.firstElementChild;
          grid.items = getItems();

          flushGrid(grid);
          cell = getContainerCell(grid.$.items, 0, 0);
        });

        it('should replace template and render text-field on editable cell click', () => {
          dblclick(cell._content);
          expect(cell._template).to.be.not.ok;
          expect(cell._renderer).to.be.ok;
          expect(getCellEditor(cell)).to.be.ok;
        });

        it('should not call start edit on second dblclick if the cell is in edit mode', () => {
          const spy = sinon.spy(grid, '_startEdit');
          dblclick(cell._content);
          input = getCellEditor(cell);
          dblclick(input);
          expect(spy).to.be.calledOnce;
        });

        it('should replace template and render text-field on editable cell Enter', () => {
          enter(cell);
          expect(cell._template).to.be.not.ok;
          expect(cell._renderer).to.be.ok;
          expect(getCellEditor(cell)).to.be.ok;
        });

        it('should replace template and render text-field on editable cell Space', () => {
          space(cell);
          expect(cell._template).to.be.not.ok;
          expect(cell._renderer).to.be.ok;
          expect(getCellEditor(cell)).to.be.ok;
        });

        it('should restore template and render updated content on edited cell Enter', () => {
          enter(cell);
          input = getCellEditor(cell);
          input.value = 'new';
          enter(input);
          expect(cell._renderer).to.be.not.ok;
          expect(cell._template).to.equal(column._bodyTemplate);
          expect(getCellEditor(cell)).to.be.not.ok;
          expect(cell._content.textContent).to.equal('0 new');
        });

        it('should restore template and reset old content on edited cell Esc', () => {
          const old = cell._content.textContent;
          enter(cell);
          input = getCellEditor(cell);
          input.value = 'new';
          esc(input);
          expect(cell._renderer).to.be.not.ok;
          expect(cell._template).to.equal(column._bodyTemplate);
          expect(getCellEditor(cell)).to.be.not.ok;
          expect(cell._content.textContent).to.equal(old);
        });
      });

      describe('edit mode renderer', () => {
        let grid, column, cell, editor;

        beforeEach(() => {
          grid = fixture('renderer');
          column = grid.firstElementChild;
          grid.items = getItems();
          flushGrid(grid);
          cell = getContainerCell(grid.$.items, 0, 0);
        });

        it('should call the edit mode renderer to cell when entering edit mode', () => {
          column.editModeRenderer = function(root, owner, model) {
            root.innerHTML = '<input>';
          };

          dblclick(cell._content);
          expect(cell._renderer).to.equal(column.editModeRenderer);
          editor = getCellEditor(cell);
          expect(editor).to.be.ok;
          expect(editor.value).to.be.equal(grid.items[0].name);
        });

        it('should call `focus()` on the custom editor component after entering the cell edit mode', () => {
          let spy;

          column.editModeRenderer = function(root, owner, model) {
            root.innerHTML = '';
            const input = document.createElement('input');
            spy = sinon.spy(input, 'focus');
            root.appendChild(input);
          };

          dblclick(cell._content);
          expect(spy).to.be.calledOnce;
        });

        it('should call `select()` on the custom editor component, if the <input> was rendered', () => {
          let spy;

          column.editModeRenderer = function(root, owner, model) {
            root.innerHTML = '';
            const input = document.createElement('input');
            spy = sinon.spy(input, 'select');
            root.appendChild(input);
          };

          dblclick(cell._content);
          expect(spy).to.be.calledOnce;
        });

        it('should exit the edit mode on custom editor component focusout event', () => {
          column.editModeRenderer = function(root, owner, model) {
            root.innerHTML = '';
            const input = document.createElement('input');
            input.value = model.item.name;
            root.appendChild(input);
          };

          dblclick(cell._content);
          editor = getCellEditor(cell);
          editor.value = 'Foo';
          editor.dispatchEvent(new CustomEvent('focusout', {bubbles: true, composed: true}));
          grid._flushStopEdit();
          expect(getCellEditor(cell)).to.not.be.ok;
          expect(cell._content.textContent).to.equal('Foo');
        });

        it('should set the column `editorType` to custom when renderer is defined', () => {
          column.editModeRenderer = function(root, owner, model) {
            root.innerHTML = '<input>';
          };
          expect(column.editorType).to.be.equal('custom');
        });

        it('should reset the column `editorType` to text when renderer is removed', () => {
          column.editModeRenderer = function(root, owner, model) {
            root.innerHTML = '<input>';
          };
          column.editModeRenderer = null;
          expect(column.editorType).to.be.equal('text');
        });

        it('should throw an error and remove template when added after renderer', () => {
          column.editModeRenderer = function(root, owner, model) {
            root.innerHTML = '<input>';
          };
          expect(() => column._editModeTemplate = {}).to.throw(Error);
          expect(column._editModeTemplate).to.be.not.ok;
        });
      });

      describe('edit mode template', () => {
        let grid, column, cell, input;

        beforeEach(() => {
          grid = fixture('template');
          grid.items = getItems();
          flushGrid(grid);
        });

        it('should stamp the edit mode template to cell when entering edit mode', () => {
          column = grid.querySelector('[path="name"]');
          cell = getContainerCell(grid.$.items, 0, 0);
          dblclick(cell._content);
          expect(cell._template).to.equal(column._editModeTemplate);
          expect(cell._content.querySelector('input')).to.be.ok;
        });

        it('should restore the cell body template after edit mode exit', () => {
          column = grid.querySelector('[path="name"]');
          cell = getContainerCell(grid.$.items, 0, 0);
          dblclick(cell._content);
          input = cell._content.querySelector('input');
          input.value = 'New';
          enter(input);
          expect(cell._template).to.equal(column._bodyTemplate);
          expect(cell._content.textContent).to.equal('New');
          expect(cell._content.querySelector('input')).to.not.be.ok;
        });

        it('should restore the cell path renderer after edit mode exit', () => {
          column = grid.querySelector('[path="age"]');
          cell = getContainerCell(grid.$.items, 0, 1);
          dblclick(cell._content);
          input = cell._content.querySelector('input');
          input.value = '32';
          enter(input);
          expect(cell._renderer).to.be.ok;
          expect(cell._template).to.be.not.ok;
          expect(cell._content.textContent.trim()).to.equal('32');
          expect(cell._content.querySelector('input')).to.not.be.ok;
        });

        it('should set the column `editorType` to custom when template is added', () => {
          column = grid.querySelector('[path="name"]');
          expect(column.editorType).to.be.equal('custom');
        });

        it('should reset the column `editorType` to text when template is removed', () => {
          column._editModeTemplate = null;
          expect(column.editorType).to.be.equal('text');
        });

        it('should throw an error and remove renderer when added after template', () => {
          column = grid.querySelector('[path="name"]');
          expect(() => column.editModeRenderer = {}).to.throw(Error);
          expect(column.editModeRenderer).to.be.not.ok;
        });
      });

      describe('editorValuePath property', () => {
        let grid, column, cell, editor;

        beforeEach(() => {
          grid = fixture('renderer');
          column = grid.firstElementChild;
          column.editorValuePath = 'user.name';
          column.editModeRenderer = function(root, owner, model) {
            root.innerHTML = '<user-editor>';
          };
          grid.items = getItems();
          flushGrid(grid);
          cell = getContainerCell(grid.$.items, 0, 0);
        });

        it('should map the cell value to valid path passed to `editorValuePath` value', () => {
          dblclick(cell._content);
          editor = getCellEditor(cell);
          expect(editor).to.be.ok;
          expect(editor.user.name).to.be.equal(grid.items[0].name);
        });

        it('should read the updated value based on `editorValuePath` after edit mode exit', () => {
          dblclick(cell._content);
          editor = getCellEditor(cell);
          editor.set('user.name', 'New');
          enter(editor);
          expect(cell._content.textContent.trim()).to.equal('New');
          expect(grid.items[0].name).to.equal('New');
        });
      });

      describe('checkbox editor type', () => {
        let grid, cell, column, editor;

        beforeEach(() => {
          grid = fixture('editor-type');
          grid.items = getItems();
          column = grid.firstElementChild;
          column.editorType = 'checkbox';
          flushGrid(grid);
          cell = getContainerCell(grid.$.items, 0, 0);
        });

        it('should render the checkbox to cell in edit mode', () => {
          dblclick(cell._content);
          editor = column._getEditorComponent(cell);
          expect(editor instanceof Vaadin.CheckboxElement).to.equal(true);
          expect(editor.checked).to.be.equal(grid.items[0].married);
        });

        it('should update value from checkbox checked after edit mode exit', () => {
          dblclick(cell._content);
          editor = column._getEditorComponent(cell);
          editor.click();
          enter(editor);
          expect(cell._content.textContent.trim()).to.equal('false');
          expect(grid.items[0].married).to.equal(false);
        });
      });

      describe('select editor type', () => {
        let grid, cell, column, editor, select;

        const nextRender = (elem) => {
          return new Promise(resolve => {
            Polymer.RenderStatus.afterNextRender(elem, resolve);
          });
        };

        beforeEach(async() => {
          grid = fixture('editor-type');
          grid.items = getItems();
          column = grid.querySelector('[path="title"]');
          column.editorType = 'select';
          column.editorOptions = ['mr', 'mrs', 'ms'];
          flushGrid(grid);
          cell = getContainerCell(grid.$.items, 0, 1);
          enter(cell._content);
          editor = getCellEditor(cell);
          select = editor._select;
          await nextRender(select);
        });

        it('should render the opened select to cell in edit mode', () => {
          expect(select instanceof Vaadin.SelectElement).to.equal(true);
          expect(select.value).to.be.equal('mrs');
          expect(select.opened).to.equal(true);
        });

        it('should open the select and stop focusout on editor click', async() => {
          select.opened = false;
          select.focusElement.click();
          const evt = new CustomEvent('focusout', {bubbles: true, composed: true});
          evt.relatedTarget = editor._overlay.querySelector('vaadin-item');
          select.dispatchEvent(evt);
          grid._flushStopEdit();
          await nextRender(select._menuElement);
          expect(select.opened).to.equal(true);
        });

        it('should close the select and exit edit mode on outside click', () => {
          document.body.click();
          expect(select.opened).to.equal(false);
        });

        it('should open the select on space key', async() => {
          space(select.focusElement);
          await nextRender(select._menuElement);
          expect(select.opened).to.equal(true);
        });

        it('should open the select on arrow down key', async() => {
          down(select.focusElement);
          await nextRender(select._menuElement);
          expect(select.opened).to.equal(true);
        });

        it('should open the select on arrow up key', async() => {
          up(select.focusElement);
          await nextRender(select._menuElement);
          expect(select.opened).to.equal(true);
        });

        it('should update value and exit edit mode when item is selected', () => {
          const item = editor._overlay.querySelector('vaadin-item');
          const value = item.textContent;
          item.click();
          expect(column._getEditorComponent(cell)).to.not.be.ok;
          expect(cell._content.textContent).to.equal(value);
        });
      });

      describe('edit on typing', () => {
        let grid, cell, columns, column, editor;

        beforeEach(() => {
          grid = fixture('editor-type');
          grid.items = getItems();
          flushGrid(grid);
          columns = grid._columnTree[0];
        });

        it('should start edit on typing if numeric key pressed', () => {
          column = grid.querySelector('[path="age"]');
          cell = getContainerCell(grid.$.items, 0, columns.indexOf(column));
          keyDownChar(cell._content, '1');
          editor = column._getEditorComponent(cell);
          expect(editor).to.be.ok;
        });

        it('should start edit on typing if character key pressed', () => {
          column = grid.querySelector('[path="name"]');
          cell = getContainerCell(grid.$.items, 0, columns.indexOf(column));
          keyDownChar(cell._content, 'a');
          editor = column._getEditorComponent(cell);
          expect(editor).to.be.ok;
        });

        it('should not start edit on typing when editor type set to checkbox', () => {
          column = grid.querySelector('[path="married"]');
          cell = getContainerCell(grid.$.items, 0, columns.indexOf(column));
          column.editorType = 'checkbox';
          keyDownChar(cell._content, 'a');
          editor = column._getEditorComponent(cell);
          expect(editor).to.be.not.ok;
        });

        it('should not start edit on typing when editor type set to select', () => {
          column = grid.querySelector('[path="title"]');
          cell = getContainerCell(grid.$.items, 0, columns.indexOf(column));
          column.editorType = 'select';
          column.editorOptions = ['mr', 'mrs', 'ms'];
          keyDownChar(cell._content, 'a');
          editor = column._getEditorComponent(cell);
          expect(editor).to.be.not.ok;
        });

        it('should not start edit on typing when editor type set to custom', () => {
          column = grid.querySelector('[path="married"]');
          cell = getContainerCell(grid.$.items, 0, columns.indexOf(column));
          column.editModeRenderer = root => {
            root.innerHTML = '<input type="checkbox">';
          };
          keyDownChar(cell._content, 'a');
          editor = column._getEditorComponent(cell);
          expect(editor).to.be.not.ok;
        });
      });

      describe('item-property-changed event', () => {

        let grid, column, firstCell, input;

        beforeEach(() => {
          grid = fixture('default');
          column = grid.firstElementChild;
          grid.items = getItems();

          flushGrid(grid);
          firstCell = getContainerCell(grid.$.items, 0, 0);
        });

        it('should be fired once cell edit completed and value has changed', done => {
          grid.addEventListener('item-property-changed', e => {
            const {value, path} = e.detail;
            expect(value).to.equal('new');
            expect(path).to.equal(column.path);
            done();
          });
          enter(firstCell);
          input = getCellEditor(firstCell);
          input.value = 'new';
          enter(input);
        });

        it('should not be fired once cell edit completed if value has not changed', () => {
          const spy = sinon.spy();
          grid.addEventListener('item-property-changed', spy);
          enter(firstCell);
          input = getCellEditor(firstCell);
          const value = input.value;
          input.value = 'new';
          input.value = value;
          enter(input);
          expect(spy).to.not.be.called;
        });

        it('should be not modify the cell content if prevented by user', done => {
          grid.addEventListener('item-property-changed', e => {
            e.preventDefault();
            flush(() => {
              expect(firstCell._content.textContent).to.equal('0 foo');
              done();
            });
          });
          enter(firstCell);
          input = getCellEditor(firstCell);
          input.value = 'new';
          enter(input);
        });
      });

      describe('vertical scrolling', () => {
        let grid, input, firstCell;

        beforeEach(() => {
          grid = fixture('default');
          grid.size = 1000;
          grid.dataProvider = infiniteDataProvider;
          flushGrid(grid);
        });

        it('should cancel edit for editable cell using template when scrolled out', () => {
          firstCell = getContainerCell(grid.$.items, 1, 0);
          dblclick(firstCell._content);

          grid._scrollToIndex(100);
          input = getCellEditor(firstCell);
          expect(input).to.be.not.ok;
        });

        it('should cancel edit for editable cell using renderer when scrolled out', () => {
          firstCell = getContainerCell(grid.$.items, 1, 1);
          dblclick(firstCell._content);

          grid._scrollToIndex(100);
          input = getCellEditor(firstCell);
          expect(input).to.be.not.ok;
        });
      });
    });
  </script>

</body>

</html>
